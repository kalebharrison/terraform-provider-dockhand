package provider

import (
	"context"
	"fmt"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

var (
	_ resource.Resource                = (*gitRepositoryResource)(nil)
	_ resource.ResourceWithConfigure   = (*gitRepositoryResource)(nil)
	_ resource.ResourceWithImportState = (*gitRepositoryResource)(nil)
)

func NewGitRepositoryResource() resource.Resource {
	return &gitRepositoryResource{}
}

type gitRepositoryResource struct {
	client *Client
}

type gitRepositoryModel struct {
	ID                 types.String `tfsdk:"id"`
	Name               types.String `tfsdk:"name"`
	URL                types.String `tfsdk:"url"`
	Branch             types.String `tfsdk:"branch"`
	ComposePath        types.String `tfsdk:"compose_path"`
	CredentialID       types.String `tfsdk:"credential_id"`
	EnvironmentID      types.String `tfsdk:"environment_id"`
	AutoUpdate         types.Bool   `tfsdk:"auto_update"`
	AutoUpdateSchedule types.String `tfsdk:"auto_update_schedule"`
	AutoUpdateCron     types.String `tfsdk:"auto_update_cron"`
	WebhookEnabled     types.Bool   `tfsdk:"webhook_enabled"`
	WebhookSecret      types.String `tfsdk:"webhook_secret"`
	LastSync           types.String `tfsdk:"last_sync"`
	LastCommit         types.String `tfsdk:"last_commit"`
	SyncStatus         types.String `tfsdk:"sync_status"`
	SyncError          types.String `tfsdk:"sync_error"`
	CreatedAt          types.String `tfsdk:"created_at"`
	UpdatedAt          types.String `tfsdk:"updated_at"`
}

func (r *gitRepositoryResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_git_repository"
}

func (r *gitRepositoryResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Dockhand Git repository integration via `/api/git/repositories`.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "Numeric Dockhand Git repository ID.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "Repository display name.",
				Required:            true,
			},
			"url": schema.StringAttribute{
				MarkdownDescription: "Git clone URL.",
				Required:            true,
			},
			"branch": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"compose_path": schema.StringAttribute{
				Computed: true,
			},
			"credential_id": schema.StringAttribute{
				MarkdownDescription: "Optional Git credential ID to use for this repo.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"environment_id": schema.StringAttribute{
				MarkdownDescription: "Optional Dockhand environment ID. Set to null to clear.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"auto_update": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"auto_update_schedule": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"auto_update_cron": schema.StringAttribute{
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"webhook_enabled": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"webhook_secret": schema.StringAttribute{
				MarkdownDescription: "Webhook secret generated by Dockhand, if enabled.",
				Computed:            true,
				Sensitive:           true,
			},
			"last_sync": schema.StringAttribute{
				Computed: true,
			},
			"last_commit": schema.StringAttribute{
				Computed: true,
			},
			"sync_status": schema.StringAttribute{
				Computed: true,
			},
			"sync_error": schema.StringAttribute{
				Computed: true,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
			},
		},
	}
}

func (r *gitRepositoryResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*Client)
	if !ok {
		resp.Diagnostics.AddError("Unexpected Resource Configure Type", fmt.Sprintf("Expected *Client, got: %T", req.ProviderData))
		return
	}
	r.client = client
}

func (r *gitRepositoryResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError("Unconfigured client", "The provider client was not configured.")
		return
	}

	var plan gitRepositoryModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := buildGitRepositoryPayload(plan)
	if err != nil {
		resp.Diagnostics.AddError("Invalid git repository configuration", err.Error())
		return
	}

	created, _, err := r.client.CreateGitRepository(ctx, payload)
	if err != nil {
		resp.Diagnostics.AddError("Error creating Dockhand git repository", err.Error())
		return
	}

	state := mergeGitRepositoryState(plan, modelFromGitRepositoryResponse(created))
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (r *gitRepositoryResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError("Unconfigured client", "The provider client was not configured.")
		return
	}

	var state gitRepositoryModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	repo, status, err := r.client.GetGitRepository(ctx, state.ID.ValueString())
	if err != nil {
		if status == 404 {
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Error reading Dockhand git repository", err.Error())
		return
	}

	newState := mergeGitRepositoryState(state, modelFromGitRepositoryResponse(repo))
	resp.Diagnostics.Append(resp.State.Set(ctx, &newState)...)
}

func (r *gitRepositoryResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError("Unconfigured client", "The provider client was not configured.")
		return
	}

	var plan gitRepositoryModel
	var state gitRepositoryModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	id := state.ID.ValueString()
	if id == "" {
		resp.Diagnostics.AddError("Missing repository ID", "Cannot update Dockhand git repository because ID is unknown.")
		return
	}

	payload, err := buildGitRepositoryPayload(plan)
	if err != nil {
		resp.Diagnostics.AddError("Invalid git repository configuration", err.Error())
		return
	}

	updated, _, err := r.client.UpdateGitRepository(ctx, id, payload)
	if err != nil {
		resp.Diagnostics.AddError("Error updating Dockhand git repository", err.Error())
		return
	}

	newState := mergeGitRepositoryState(plan, modelFromGitRepositoryResponse(updated))
	resp.Diagnostics.Append(resp.State.Set(ctx, &newState)...)
}

func (r *gitRepositoryResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	if r.client == nil {
		resp.Diagnostics.AddError("Unconfigured client", "The provider client was not configured.")
		return
	}

	var state gitRepositoryModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	status, err := r.client.DeleteGitRepository(ctx, state.ID.ValueString())
	if err != nil && status != 404 {
		resp.Diagnostics.AddError("Error deleting Dockhand git repository", err.Error())
		return
	}
}

func (r *gitRepositoryResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}

func buildGitRepositoryPayload(plan gitRepositoryModel) (gitRepositoryPayload, error) {
	name := plan.Name.ValueString()
	url := plan.URL.ValueString()
	if name == "" {
		return gitRepositoryPayload{}, fmt.Errorf("name is required")
	}
	if url == "" {
		return gitRepositoryPayload{}, fmt.Errorf("url is required")
	}

	payload := gitRepositoryPayload{
		Name: name,
		URL:  url,
	}

	if !plan.Branch.IsNull() && !plan.Branch.IsUnknown() {
		v := plan.Branch.ValueString()
		payload.Branch = &v
	}
	if !plan.CredentialID.IsNull() && !plan.CredentialID.IsUnknown() {
		raw := plan.CredentialID.ValueString()
		v, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return gitRepositoryPayload{}, fmt.Errorf("credential_id must be a numeric string: %w", err)
		}
		payload.CredentialID = &v
	}
	if !plan.EnvironmentID.IsNull() && !plan.EnvironmentID.IsUnknown() {
		raw := plan.EnvironmentID.ValueString()
		v, err := strconv.ParseInt(raw, 10, 64)
		if err != nil {
			return gitRepositoryPayload{}, fmt.Errorf("environment_id must be a numeric string: %w", err)
		}
		payload.EnvironmentID = &v
	}
	if !plan.AutoUpdate.IsNull() && !plan.AutoUpdate.IsUnknown() {
		v := plan.AutoUpdate.ValueBool()
		payload.AutoUpdate = &v
	}
	if !plan.AutoUpdateSchedule.IsNull() && !plan.AutoUpdateSchedule.IsUnknown() {
		v := plan.AutoUpdateSchedule.ValueString()
		payload.AutoUpdateSchedule = &v
	}
	if !plan.AutoUpdateCron.IsNull() && !plan.AutoUpdateCron.IsUnknown() {
		v := plan.AutoUpdateCron.ValueString()
		payload.AutoUpdateCron = &v
	}
	if !plan.WebhookEnabled.IsNull() && !plan.WebhookEnabled.IsUnknown() {
		v := plan.WebhookEnabled.ValueBool()
		payload.WebhookEnabled = &v
	}

	return payload, nil
}

func modelFromGitRepositoryResponse(in *gitRepositoryResponse) gitRepositoryModel {
	out := gitRepositoryModel{
		ID:             types.StringValue(fmt.Sprintf("%d", in.ID)),
		Name:           types.StringValue(in.Name),
		URL:            types.StringValue(in.URL),
		AutoUpdate:     types.BoolValue(in.AutoUpdate),
		WebhookEnabled: types.BoolValue(in.WebhookEnabled),
	}

	if in.Branch != nil {
		out.Branch = types.StringValue(*in.Branch)
	} else {
		out.Branch = types.StringNull()
	}
	if in.ComposePath != nil {
		out.ComposePath = types.StringValue(*in.ComposePath)
	} else {
		out.ComposePath = types.StringNull()
	}
	if in.CredentialID != nil {
		out.CredentialID = types.StringValue(fmt.Sprintf("%d", *in.CredentialID))
	} else {
		out.CredentialID = types.StringNull()
	}
	if in.EnvironmentID != nil {
		out.EnvironmentID = types.StringValue(fmt.Sprintf("%d", *in.EnvironmentID))
	} else {
		out.EnvironmentID = types.StringNull()
	}
	if in.AutoUpdateSchedule != nil {
		out.AutoUpdateSchedule = types.StringValue(*in.AutoUpdateSchedule)
	} else {
		out.AutoUpdateSchedule = types.StringNull()
	}
	if in.AutoUpdateCron != nil {
		out.AutoUpdateCron = types.StringValue(*in.AutoUpdateCron)
	} else {
		out.AutoUpdateCron = types.StringNull()
	}
	if in.WebhookSecret != nil {
		out.WebhookSecret = types.StringValue(*in.WebhookSecret)
	} else {
		out.WebhookSecret = types.StringNull()
	}
	if in.LastSync != nil {
		out.LastSync = types.StringValue(*in.LastSync)
	} else {
		out.LastSync = types.StringNull()
	}
	if in.LastCommit != nil {
		out.LastCommit = types.StringValue(*in.LastCommit)
	} else {
		out.LastCommit = types.StringNull()
	}
	if in.SyncStatus != nil {
		out.SyncStatus = types.StringValue(*in.SyncStatus)
	} else {
		out.SyncStatus = types.StringNull()
	}
	if in.SyncError != nil {
		out.SyncError = types.StringValue(*in.SyncError)
	} else {
		out.SyncError = types.StringNull()
	}
	if in.CreatedAt != nil {
		out.CreatedAt = types.StringValue(*in.CreatedAt)
	} else {
		out.CreatedAt = types.StringNull()
	}
	if in.UpdatedAt != nil {
		out.UpdatedAt = types.StringValue(*in.UpdatedAt)
	} else {
		out.UpdatedAt = types.StringNull()
	}

	return out
}

func mergeGitRepositoryState(preferred gitRepositoryModel, remote gitRepositoryModel) gitRepositoryModel {
	out := remote

	if (out.EnvironmentID.IsNull() || out.EnvironmentID.IsUnknown()) && !preferred.EnvironmentID.IsNull() && !preferred.EnvironmentID.IsUnknown() {
		out.EnvironmentID = preferred.EnvironmentID
	}

	return out
}
